package fr.emn.gestion_colocation.abstraction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class BDColocation {
	
	private static Connection connexion;
	
	/**
	 * driver JDBC
	 */
	private static final String jdbcDriver = "org.hsqldb.jdbcDriver";

	/**
	 * fichiers db
	 */
	private static final String database = "jdbc:hsqldb:file:db/colocationdb";

	/**
	 * utilisateur qui se connecte Ã  la base de donnÃ©es
	 */
	private static final String user = "sa";

	/**
	 * mot de passe pour se connecter Ã  la base de donnÃ©es
	 */
	private static final String password = "";

	/**
	 * Connexion Ã  la base de donnÃ©e
	 */
	public static void connexionBD() {
		try {
			// On commence par charger le driver JDBC d'HyperSQL
			Class.forName(jdbcDriver).newInstance();
		} catch (InstantiationException e) {
			System.out.println("ERROR: failed to load HSQLDB JDBC driver.");
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}

		try {
			// Puis on se connecte Ã  la base de donnees
			connexion = DriverManager.getConnection(database, user, password);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * ArrÃªte correctement HyperSQL
	 * 
	 * @throws SQLException
	 */
	public static void arretBD() throws SQLException {
		Statement st = connexion.createStatement();
		// On envoie l'instruction pour arreter proprement HSQLDB
		st.execute("SHUTDOWN");
		// On ferme la connexion
		connexion.close();
	}
	
	public static void creerBDD() {
		 
		try{
			/* Ajout de l'eleve dans la table eleve*/
			Statement stmt = connexion.createStatement();
			stmt.executeUpdate("drop table Depense if exists;" +
					"drop table Corvee if exists;" +
					"drop table Colocataire if exists;" +
					"drop table Tache if exists;" +
					"drop table Type_tache if exists;" +
					"CREATE TABLE Colocataire (" +
					"	pseudo VARCHAR(100)," +
					"	nom_coloc VARCHAR(100)," +
					"	prenom_coloc VARCHAR(100)," +
					"	PRIMARY KEY (pseudo)" +
					");" +
					"CREATE TABLE Type_tache(" +
					"	type_tache char(30), " +
					"	primary key(type_tache)" +
					");" +
					"CREATE TABLE Tache (" +
					"	id_tache INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"	type_tache CHAR(30)," +
					"	nom_tache VARCHAR(100)," +
					"	valeur INT," +
					"	PRIMARY KEY (id_tache)," +
					"	FOREIGN KEY(type_tache) REFERENCES Type_tache(type_tache) ON DELETE CASCADE ON UPDATE CASCADE" +
					");" +
					"CREATE TABLE Depense (" +
					"	id_depense INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"	intitule VARCHAR(100)," +
					"	pseudoemetteur VARCHAR(100)," +
					"	pseudoreceveur VARCHAR(100)," +
					"	montant FLOAT(2)," +
					"	date_depense DATE,	" +
					"	commune BOOLEAN DEFAULT TRUE," +
					"	alimentaire BOOLEAN DEFAULT TRUE," +
					"	PRIMARY KEY (id_depense)," +
					"	FOREIGN KEY(pseudoemetteur) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE," +
					"	FOREIGN KEY(pseudoreceveur) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE" +
					");" +
					"CREATE TABLE Corvee (" +
					"id_corvee INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"id_tache INT," +
					"pseudo VARCHAR(100)," +
					"date_corvee DATE," +
					"definitive BOOLEAN DEFAULT FALSE," +
					"PRIMARY KEY (id_corvee)," +
					"FOREIGN KEY (id_tache) REFERENCES Tache(id_tache) ON DELETE CASCADE ON UPDATE CASCADE," +
					"FOREIGN KEY (pseudo) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE" +
					");");
			stmt.executeUpdate("CHECKPOINT");
		}
		catch(SQLException e){
			e.printStackTrace();
		}
	}
	
	public static Connection getConnexion() {
		return connexion;
	}
	
	public static void main(String[] args) {
		BDColocation.connexionBD();
		BDColocation.creerBDD();
		
		try {
			BDColocation.getConnexion().createStatement();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}
