package fr.emn.gestion_colocation.abstraction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Vector;

public class ColocationJDBC extends Colocation {

	private Statement stmt;

	/**
	 * Constructeur établissant la connexion à la base de données
	 * et initialise stmt
	 */
	public ColocationJDBC() {
		String database = "jdbc:hsqldb:file:db/colocationdb";
		try {
			Connection conn = DriverManager.getConnection(database, "sa", "");
			stmt = conn.createStatement();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	@Override
	public Vector<String> findAllRemboursements() {
		// TODO Auto-generated method stub
		Vector<String> vec = new Vector<String>();
		vec.add("cloise12 doit 5€ à bmenou12 (macdo)");
		vec.add("gpain12 doit 20€ à bmenou12 (karting)");
		return vec;
	}

	@Override
	public Object[][] findEntreesSortiesAsTable() {
		// TODO Auto-generated method stub
		Object[][] dettes = {{"bmenou12","0","6"},{"cloise12","6","0"} };
		return dettes;
	}

	@Override
	public Vector<String> allRemboursementsOptimaux() {
		// TODO Auto-generated method stub
		Vector<String> vec = new Vector<String>();
		vec.add("cloise12 doit 5€ à bmenou12");
		vec.add("gpain12 doit 20€ à bmenou12");
		return vec;
	}

	@Override
	public double[][] allRemboursementsAsTable() {
		// TODO Auto-generated method stub
		return null;
	}

	public void saveDepense(Depense d, Vector<Colocataire> profiteurs, boolean creation) {
		try{
			if (creation){
				/* Ajout de la note dans la table correction*/
				stmt.executeUpdate("insert into depense values;"
						);
			}
		}
		catch(SQLException e){
			e.printStackTrace();
		}
		this.setChanged();
		this.notifyObservers(CHANGEMENT_DEPENSES);
	}

	@Override
	public Colocataire[] findAllColocataires() {
		try{

			ResultSet rs1 = stmt.executeQuery("Select prenom_coloc from Colocataire");
			int i = 0;
			while(rs1.next()){
				i++;
			}

			if(i!=0){
				Colocataire[] ret = new Colocataire[i];

				String myQuerry = "Select pseudo, nom_coloc, prenom_coloc" +
						" from  Colocataire" +
						" order by nom_coloc asc";

				ResultSet rs = stmt.executeQuery(myQuerry);
				int j = 0;
				while(rs.next()){

					Colocataire coloc = new Colocataire(rs.getString("pseudo"),rs.getString("nom_coloc"),
							rs.getString("prenom_coloc"));

					ret[j]=coloc;
					j++;
				}
				return ret;
			}
			else {
				Colocataire[] defaut = new Colocataire[1];
				defaut[0]=new Colocataire(" "," "," ");
				return defaut;
			}
		}
		catch(Exception e){

			e.printStackTrace();
			return null;

		}
	}

	@Override
	public boolean isCree() {
		Colocataire[] verif = findAllColocataires();
		return !verif[0].getPseudo().equals(" ");
	}

	@Override
	public void saveColocataire(Colocataire n) {
		try{
			/* Ajout de l'eleve dans la table eleve*/
			stmt.executeUpdate("insert into Colocataire (pseudo,nom_coloc,prenom_coloc) " +
					"values('"+n.getPseudo()+"','"+n.getNom()+"','"+n.getPrenom()+"');");	
		}
		catch(SQLException e){
			e.printStackTrace();
		}
	}

	@Override
	public void deleteColocation() {
		// TODO Auto-generated method stub
		try{
			/* Ajout de l'eleve dans la table eleve*/
			stmt.executeUpdate("drop table Depense if exists;" +
					"drop table Corvee if exists;" +
					"drop table Colocataire if exists;" +
					"drop table Tache if exists;" +
					"drop table Type_tache if exists;" +
					"CREATE TABLE Colocataire (" +
					"	pseudo VARCHAR(100)," +
					"	nom_coloc VARCHAR(100)," +
					"	prenom_coloc VARCHAR(100)," +
					"	PRIMARY KEY (pseudo)" +
					");" +
					"CREATE TABLE Type_tache(" +
					"	type_tache char(30), " +
					"	primary key(type_tache)" +
					");" +
					"CREATE TABLE Tache (" +
					"	id_tache INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"	type_tache CHAR(30)," +
					"	nom_tache VARCHAR(100)," +
					"	valeur INT," +
					"	PRIMARY KEY (id_tache)," +
					"	FOREIGN KEY(type_tache) REFERENCES Type_tache(type_tache) ON DELETE CASCADE ON UPDATE CASCADE" +
					");" +
					"CREATE TABLE Depense (" +
					"	id_depense INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"	intitule VARCHAR(100)," +
					"	pseudoemetteur VARCHAR(100)," +
					"	pseudoreceveur VARCHAR(100)," +
					"	montant FLOAT(2)," +
					"	date_depense DATE,	" +
					"	commune BOOLEAN DEFAULT TRUE," +
					"	alimentaire BOOLEAN DEFAULT TRUE," +
					"	PRIMARY KEY (id_depense)," +
					"	FOREIGN KEY(pseudoemetteur) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE," +
					"	FOREIGN KEY(pseudoreceveur) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE" +
					");" +
					"CREATE TABLE Corvee (" +
					"id_corvee INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1)," +
					"id_tache INT," +
					"pseudo VARCHAR(100)," +
					"date_corvee DATE," +
					"definitive BOOLEAN DEFAULT FALSE," +
					"PRIMARY KEY (id_corvee)," +
					"FOREIGN KEY (id_tache) REFERENCES Tache(id_tache) ON DELETE CASCADE ON UPDATE CASCADE," +
					"FOREIGN KEY (pseudo) REFERENCES Colocataire(pseudo) ON DELETE CASCADE ON UPDATE CASCADE" +
					");");
			stmt.executeUpdate("CHECKPOINT");
		}
		catch(SQLException e){
			e.printStackTrace();
		}
		this.setChanged();
		this.notifyObservers(CHANGEMENT_COLOC);
	}
}
